# We can select type of VAR model
VAR_type="VAR"
VAR_type="BVAR"
if (VAR_type=="BVAR")
{
# Simon's settings for BVAR(4)
lambda_BVAR <- 10
p_full<-4
q_full<-0
}
if (VAR_type=="VAR")
{
# Marc's settings for VAR
p_full<-p
q_full<-q
}
ht_mssa_vec<-c(6.380160,  6.738270,   7.232453,   7.225927,   7.033768)
names(ht_mssa_vec)<-colnames(x_mat)
# Forecast horizons: M-SSA is optimized for each forecast horizon in h_vec
h_vec<-0:6
# Forecast excesses: see tutorial 7.2, exercise 2 for background
f_excess<-c(5,rep(4,length(select_vec_multi)-1))
# Run the M-SSA wrapper, see tutorial 7.2
#   -The function computes M-SSA and M-MSE for each forecast horizon h in h_vec
final_mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat_wc,lambda_HP,L,date_to_fit_all,p_full,q_full,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi,VAR_type,lambda_BVAR)
# Target filter: lambda_HP is the single most important hyperparameter, see tutorial 7.1 for a discussion
lambda_HP<-160
# Filter length: nearly 8 years is fine for the selected lambda_HP (filter weights decay sufficiently fast)
#   The length should be an odd number (see tutorial 7.1)
L<-31
# In-sample span for VAR, i.e., M-SSA (the proposed design is quite insensitive to this specification because the VAR is parsimoniously parameterized
date_to_fit<-"2008"
# VARMA model orders: keep the model simple in particular for short/tight in-sample spans
p<-1
q<-0
# Holding-times (HT): controls smoothness of M-SSA (the following numbers are pasted from the original predictor)
#   -Increasing these numbers leads to predictors with less zero-crossings (smoother), see tutorial 7.1
ht_mssa_vec<-c(6.380160,  6.738270,   7.232453,   7.225927,   7.033768)
names(ht_mssa_vec)<-colnames(x_mat)
# Forecast horizons: M-SSA is optimized for each forecast horizon in h_vec
h_vec<-0:6
# Forecast excesses: see tutorial 7.2, exercise 2 for background
f_excess<-c(5,rep(4,length(select_vec_multi)-1))
# Run the wrapper, see tutorial 7.2
#   -The function computes M-SSA for each forecast horizon h in h_vec
mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat,lambda_HP,L,date_to_fit,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
# Target filter: lambda_HP is the single most important hyperparameter, see tutorial 7.1 for a discussion
lambda_HP<-160
# Filter length: nearly 8 years is fine for the selected lambda_HP (filter weights decay sufficiently fast)
#   The length should be an odd number (see tutorial 7.1)
L<-31
# In-sample span for VAR, i.e., M-SSA (the proposed design is quite insensitive to this specification because the VAR is parsimoniously parameterized
date_to_fit<-"2008"
# VARMA model orders: keep the model simple in particular for short/tight in-sample spans
p<-1
q<-0
# Holding-times (HT): controls smoothness of M-SSA (the following numbers are pasted from the original predictor)
#   -Increasing these numbers leads to predictors with less zero-crossings (smoother), see tutorial 7.1
ht_mssa_vec<-c(6.380160,  6.738270,   7.232453,   7.225927,   7.033768)
names(ht_mssa_vec)<-colnames(x_mat)
# Forecast horizons: M-SSA is optimized for each forecast horizon in h_vec
h_vec<-0:6
# Forecast excesses: see tutorial 7.2, exercise 2 for background
f_excess<-c(5,rep(4,length(select_vec_multi)-1))
# Run the wrapper, see tutorial 7.2
#   -The function computes M-SSA for each forecast horizon h in h_vec
mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat,lambda_HP,L,date_to_fit,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
source("C:/Users/marca/OneDrive/2025/Projects/R-package-SSA-Predictor/R/M_SSA_utility_functions.R", echo=TRUE)
# Target filter: lambda_HP is the single most important hyperparameter, see tutorial 7.1 for a discussion
lambda_HP<-160
# Filter length: nearly 8 years is fine for the selected lambda_HP (filter weights decay sufficiently fast)
#   The length should be an odd number (see tutorial 7.1)
L<-31
# We use all the data (without pandemic)
date_to_fit_all<-"3000"
# We can select type of VAR model
VAR_type="VAR"
VAR_type="BVAR"
if (VAR_type=="BVAR")
{
# Simon's settings for BVAR(4)
lambda_BVAR <- 10
p_full<-4
q_full<-0
}
if (VAR_type=="VAR")
{
# Marc's settings for VAR
p_full<-p
q_full<-q
}
ht_mssa_vec<-c(6.380160,  6.738270,   7.232453,   7.225927,   7.033768)
names(ht_mssa_vec)<-colnames(x_mat)
# Forecast horizons: M-SSA is optimized for each forecast horizon in h_vec
h_vec<-0:6
# Forecast excesses: see tutorial 7.2, exercise 2 for background
f_excess<-c(5,rep(4,length(select_vec_multi)-1))
# Run the M-SSA wrapper, see tutorial 7.2
#   -The function computes M-SSA and M-MSE for each forecast horizon h in h_vec
final_mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat_wc,lambda_HP,L,date_to_fit_all,p_full,q_full,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi,VAR_type,lambda_BVAR)
# Target filter: lambda_HP is the single most important hyperparameter, see tutorial 7.1 for a discussion
lambda_HP<-160
# Filter length: nearly 8 years is fine for the selected lambda_HP (filter weights decay sufficiently fast)
#   The length should be an odd number (see tutorial 7.1)
L<-31
# In-sample span for VAR, i.e., M-SSA (the proposed design is quite insensitive to this specification because the VAR is parsimoniously parameterized
date_to_fit<-"2008"
# VARMA model orders: keep the model simple in particular for short/tight in-sample spans
p<-1
q<-0
# Holding-times (HT): controls smoothness of M-SSA (the following numbers are pasted from the original predictor)
#   -Increasing these numbers leads to predictors with less zero-crossings (smoother), see tutorial 7.1
ht_mssa_vec<-c(6.380160,  6.738270,   7.232453,   7.225927,   7.033768)
names(ht_mssa_vec)<-colnames(x_mat)
# Forecast horizons: M-SSA is optimized for each forecast horizon in h_vec
h_vec<-0:6
# Forecast excesses: see tutorial 7.2, exercise 2 for background
f_excess<-c(5,rep(4,length(select_vec_multi)-1))
# Run the wrapper, see tutorial 7.2
#   -The function computes M-SSA for each forecast horizon h in h_vec
mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat,lambda_HP,L,date_to_fit,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
# Tutorial 7.4
# Main purposes:
# 1. Forecasting German GDP (BIP) multiple quarters ahead
#   -Derive a new M-SSA components predictor which addresses MSE forecast performances when tracking BIP
#     -The original M-SSA predictor (without the attribute `components') proposed in tutorial 7.3 is
#         standardized: neither level nor scale were calibrated to track BIP
#     -The original M-SSA predictor was designed to track dynamic changes in the trend growth-rate of BIP (HP-BIP)
#     -The original M-SSA predictor was based on aggregating equally the standardized M-SSA components
#   -We here propose a more refined design, the `M-SSA components predictor', whereby equal weighting
#       (of M-SSA components) is replaced by an additional (new) optimal weighting step.
# 2. Interpretability:
#   -Exploit the M-SSA components to gauge forecasts by the proposed M-SSA predictor(s)
#   -How trustworthy is a change of the predictor outlook?
# 3. Explainability:
#   -Justify the design and construction steps underlying the proposed M-SSA predictor(s)
#   -Determine which step(s) in the construction of the predictor(s) generate(s) forecast gains?
# Proceeding:
# -We rely on the design proposed in tutorial 7.3, exercise 1
# -We then add a new optimal weighting step in the construction of the final predictor
# The tutorial is organized into 6 exercises
# -Exercise 1
#   -M-SSA components: derive M-SSA components and replicate the original M-SSA predictor (tutorial 7.3)
#   -Interpretability: rely on M-SSA components to gauge forecasts (reliability/trustworthiness)
#   -Forecast BIP: new additional optimization step
#   -Out-of-sample performance evaluation
#     -Comparison vs. simple mean, direct forecast and original M-SSA predictor
# -Exercise 2
#   -Analysis of revisions of new (real-time out-of-sample) M-SSA components predictor
# -Exercise 3
#   -Skipped
# -Exercise 4
#   -Explainability: why does the M-SSA component predictor outperform specifically at multiple-quarters
#     ahead forecast horizons?
# -Exercise 5
#   -Specify and compute an `M-MSE component predictor' (same as M-SSA but without HT imposed: less smooth)
#   -Compare MSE forecast performances to the simple mean benchmark and the (new) M-SSA component predictor
# -Exercise 6
#   -Compute final M-SSA and M-MSE component predictors based on full data information, discarding the
#     singular Pandemic data for estimation of parameters
#----------------------------------------------
# Start with a clean sheet
rm(list=ls())
# Load the required R-libraries
# Standard filter package
library(mFilter)
# Multivariate time series: VARMA model for macro indicators: used here for simulation purposes only
library(MTS)
# HAC estimate of standard deviations in the presence of autocorrelation and heteroscedasticity
library(sandwich)
# Extended time series
library(xts)
# Library for Diebold-Mariano test of equal forecast performance
library(multDM)
# GARCH model: for improving regression estimates
library(fGarch)
# Packages for Ridge and LASSO
library(MASS)
library(glmnet)
# Load the relevant M-SSA functionalities
# M-SSA functions
source(paste(getwd(),"/R/functions_MSSA.r",sep=""))
# Load signal extraction functions used for JBCY paper (relies on mFilter)
source(paste(getwd(),"/R/HP_JBCY_functions.r",sep=""))
# Utility functions for M-SSA, see tutorial
source(paste(getwd(),"/R/M_SSA_utility_functions.r",sep=""))
#------------------------------------------------------------------------
# Load the data and select the relevant indicators: see tutorials 7.2 and 7.3 for background
load(file=paste(getwd(),"\\Data\\macro",sep=""))
# Publication lag: we assume a lag of one quarter for BIP
lag_vec<-c(1,rep(0,ncol(data)-1))
# Plot the data
# The real-time BIP (red) is lagging the target (black) by lag_vec[1] quarters (publication lag)
par(mfrow=c(1,1))
mplot<-data[,-1]
colo<-c(rainbow(ncol(data)-1))
main_title<-paste("Quarterly indicators",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],lwd=c(2,rep(1,ncol(data)-1)),ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i],lwd=1,lty=1)
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
abline(h=0)
axis(1,at=c(1,4*1:(nrow(mplot)/4)),labels=rownames(mplot)[c(1,4*1:(nrow(mplot)/4))])
axis(2)
box()
# -The explanatory variables BIP (red line) and ip (orange) are right shifted
#   -Publication lags: BIP one quarter and ip two months (see data_monthly for the 2-month lag of ip)
# Select macro indicators for M-SSA
select_vec_multi<-c("BIP","ip","ifo_c","ESI","spr_10y_3m")
x_mat<-data[,select_vec_multi]
rownames(x_mat)<-rownames(data)
n<-dim(x_mat)[2]
# Number of observations
len<-dim(x_mat)[1]
##################################################################################
# Exercise 1 Working with M-SSA (sub-)components
#   -We rely on the design proposed in tutorial 7.3, exercise 1
# Exercise 1.0: brief summary of original M-SSA predictor (tutorial 7.3)
# Target filter: lambda_HP is the single most important hyperparameter, see tutorial 7.1 for a discussion
lambda_HP<-160
# Filter length: nearly 8 years is fine for the selected lambda_HP (filter weights decay sufficiently fast)
#   The length should be an odd number (see tutorial 7.1)
L<-31
# In-sample span for VAR, i.e., M-SSA (the proposed design is quite insensitive to this specification because the VAR is parsimoniously parameterized
date_to_fit<-"2008"
# VARMA model orders: keep the model simple in particular for short/tight in-sample spans
p<-1
q<-0
# Holding-times (HT): controls smoothness of M-SSA (the following numbers are pasted from the original predictor)
#   -Increasing these numbers leads to predictors with less zero-crossings (smoother), see tutorial 7.1
ht_mssa_vec<-c(6.380160,  6.738270,   7.232453,   7.225927,   7.033768)
names(ht_mssa_vec)<-colnames(x_mat)
# Forecast horizons: M-SSA is optimized for each forecast horizon in h_vec
h_vec<-0:6
# Forecast excesses: see tutorial 7.2, exercise 2 for background
f_excess<-c(5,rep(4,length(select_vec_multi)-1))
# Run the wrapper, see tutorial 7.2
#   -The function computes M-SSA for each forecast horizon h in h_vec
mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat,lambda_HP,L,date_to_fit,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat,lambda_HP,L,date_to_fit,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
source("C:/Users/marca/OneDrive/2025/Projects/R-package-SSA-Predictor/R/M_SSA_utility_functions.R", echo=TRUE)
# Tutorial 7.4
# Main purposes:
# 1. Forecasting German GDP (BIP) multiple quarters ahead
#   -Derive a new M-SSA components predictor which addresses MSE forecast performances when tracking BIP
#     -The original M-SSA predictor (without the attribute `components') proposed in tutorial 7.3 is
#         standardized: neither level nor scale were calibrated to track BIP
#     -The original M-SSA predictor was designed to track dynamic changes in the trend growth-rate of BIP (HP-BIP)
#     -The original M-SSA predictor was based on aggregating equally the standardized M-SSA components
#   -We here propose a more refined design, the `M-SSA components predictor', whereby equal weighting
#       (of M-SSA components) is replaced by an additional (new) optimal weighting step.
# 2. Interpretability:
#   -Exploit the M-SSA components to gauge forecasts by the proposed M-SSA predictor(s)
#   -How trustworthy is a change of the predictor outlook?
# 3. Explainability:
#   -Justify the design and construction steps underlying the proposed M-SSA predictor(s)
#   -Determine which step(s) in the construction of the predictor(s) generate(s) forecast gains?
# Proceeding:
# -We rely on the design proposed in tutorial 7.3, exercise 1
# -We then add a new optimal weighting step in the construction of the final predictor
# The tutorial is organized into 6 exercises
# -Exercise 1
#   -M-SSA components: derive M-SSA components and replicate the original M-SSA predictor (tutorial 7.3)
#   -Interpretability: rely on M-SSA components to gauge forecasts (reliability/trustworthiness)
#   -Forecast BIP: new additional optimization step
#   -Out-of-sample performance evaluation
#     -Comparison vs. simple mean, direct forecast and original M-SSA predictor
# -Exercise 2
#   -Analysis of revisions of new (real-time out-of-sample) M-SSA components predictor
# -Exercise 3
#   -Skipped
# -Exercise 4
#   -Explainability: why does the M-SSA component predictor outperform specifically at multiple-quarters
#     ahead forecast horizons?
# -Exercise 5
#   -Specify and compute an `M-MSE component predictor' (same as M-SSA but without HT imposed: less smooth)
#   -Compare MSE forecast performances to the simple mean benchmark and the (new) M-SSA component predictor
# -Exercise 6
#   -Compute final M-SSA and M-MSE component predictors based on full data information, discarding the
#     singular Pandemic data for estimation of parameters
#----------------------------------------------
# Start with a clean sheet
rm(list=ls())
# Load the required R-libraries
# Standard filter package
library(mFilter)
# Multivariate time series: VARMA model for macro indicators: used here for simulation purposes only
library(MTS)
# HAC estimate of standard deviations in the presence of autocorrelation and heteroscedasticity
library(sandwich)
# Extended time series
library(xts)
# Library for Diebold-Mariano test of equal forecast performance
library(multDM)
# GARCH model: for improving regression estimates
library(fGarch)
# Packages for Ridge and LASSO
library(MASS)
library(glmnet)
# Load the relevant M-SSA functionalities
# M-SSA functions
source(paste(getwd(),"/R/functions_MSSA.r",sep=""))
# Load signal extraction functions used for JBCY paper (relies on mFilter)
source(paste(getwd(),"/R/HP_JBCY_functions.r",sep=""))
# Utility functions for M-SSA, see tutorial
source(paste(getwd(),"/R/M_SSA_utility_functions.r",sep=""))
#------------------------------------------------------------------------
# Load the data and select the relevant indicators: see tutorials 7.2 and 7.3 for background
load(file=paste(getwd(),"\\Data\\macro",sep=""))
# Publication lag: we assume a lag of one quarter for BIP
lag_vec<-c(1,rep(0,ncol(data)-1))
# Plot the data
# The real-time BIP (red) is lagging the target (black) by lag_vec[1] quarters (publication lag)
par(mfrow=c(1,1))
mplot<-data[,-1]
colo<-c(rainbow(ncol(data)-1))
main_title<-paste("Quarterly indicators",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],lwd=c(2,rep(1,ncol(data)-1)),ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i],lwd=1,lty=1)
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
abline(h=0)
axis(1,at=c(1,4*1:(nrow(mplot)/4)),labels=rownames(mplot)[c(1,4*1:(nrow(mplot)/4))])
axis(2)
box()
# -The explanatory variables BIP (red line) and ip (orange) are right shifted
#   -Publication lags: BIP one quarter and ip two months (see data_monthly for the 2-month lag of ip)
# Select macro indicators for M-SSA
select_vec_multi<-c("BIP","ip","ifo_c","ESI","spr_10y_3m")
x_mat<-data[,select_vec_multi]
rownames(x_mat)<-rownames(data)
n<-dim(x_mat)[2]
# Number of observations
len<-dim(x_mat)[1]
##################################################################################
# Exercise 1 Working with M-SSA (sub-)components
#   -We rely on the design proposed in tutorial 7.3, exercise 1
# Exercise 1.0: brief summary of original M-SSA predictor (tutorial 7.3)
# Target filter: lambda_HP is the single most important hyperparameter, see tutorial 7.1 for a discussion
lambda_HP<-160
# Filter length: nearly 8 years is fine for the selected lambda_HP (filter weights decay sufficiently fast)
#   The length should be an odd number (see tutorial 7.1)
L<-31
# In-sample span for VAR, i.e., M-SSA (the proposed design is quite insensitive to this specification because the VAR is parsimoniously parameterized
date_to_fit<-"2008"
# VARMA model orders: keep the model simple in particular for short/tight in-sample spans
p<-1
q<-0
# Holding-times (HT): controls smoothness of M-SSA (the following numbers are pasted from the original predictor)
#   -Increasing these numbers leads to predictors with less zero-crossings (smoother), see tutorial 7.1
ht_mssa_vec<-c(6.380160,  6.738270,   7.232453,   7.225927,   7.033768)
names(ht_mssa_vec)<-colnames(x_mat)
# Forecast horizons: M-SSA is optimized for each forecast horizon in h_vec
h_vec<-0:6
# Forecast excesses: see tutorial 7.2, exercise 2 for background
f_excess<-c(5,rep(4,length(select_vec_multi)-1))
# Run the wrapper, see tutorial 7.2
#   -The function computes M-SSA for each forecast horizon h in h_vec
mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat,lambda_HP,L,date_to_fit,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
source("C:/Users/marca/OneDrive/2025/Projects/R-package-SSA-Predictor/R/M_SSA_utility_functions.R", echo=TRUE)
# Tutorial 7.4
# Main purposes:
# 1. Forecasting German GDP (BIP) multiple quarters ahead
#   -Derive a new M-SSA components predictor which addresses MSE forecast performances when tracking BIP
#     -The original M-SSA predictor (without the attribute `components') proposed in tutorial 7.3 is
#         standardized: neither level nor scale were calibrated to track BIP
#     -The original M-SSA predictor was designed to track dynamic changes in the trend growth-rate of BIP (HP-BIP)
#     -The original M-SSA predictor was based on aggregating equally the standardized M-SSA components
#   -We here propose a more refined design, the `M-SSA components predictor', whereby equal weighting
#       (of M-SSA components) is replaced by an additional (new) optimal weighting step.
# 2. Interpretability:
#   -Exploit the M-SSA components to gauge forecasts by the proposed M-SSA predictor(s)
#   -How trustworthy is a change of the predictor outlook?
# 3. Explainability:
#   -Justify the design and construction steps underlying the proposed M-SSA predictor(s)
#   -Determine which step(s) in the construction of the predictor(s) generate(s) forecast gains?
# Proceeding:
# -We rely on the design proposed in tutorial 7.3, exercise 1
# -We then add a new optimal weighting step in the construction of the final predictor
# The tutorial is organized into 6 exercises
# -Exercise 1
#   -M-SSA components: derive M-SSA components and replicate the original M-SSA predictor (tutorial 7.3)
#   -Interpretability: rely on M-SSA components to gauge forecasts (reliability/trustworthiness)
#   -Forecast BIP: new additional optimization step
#   -Out-of-sample performance evaluation
#     -Comparison vs. simple mean, direct forecast and original M-SSA predictor
# -Exercise 2
#   -Analysis of revisions of new (real-time out-of-sample) M-SSA components predictor
# -Exercise 3
#   -Skipped
# -Exercise 4
#   -Explainability: why does the M-SSA component predictor outperform specifically at multiple-quarters
#     ahead forecast horizons?
# -Exercise 5
#   -Specify and compute an `M-MSE component predictor' (same as M-SSA but without HT imposed: less smooth)
#   -Compare MSE forecast performances to the simple mean benchmark and the (new) M-SSA component predictor
# -Exercise 6
#   -Compute final M-SSA and M-MSE component predictors based on full data information, discarding the
#     singular Pandemic data for estimation of parameters
#----------------------------------------------
# Start with a clean sheet
rm(list=ls())
# Load the required R-libraries
# Standard filter package
library(mFilter)
# Multivariate time series: VARMA model for macro indicators: used here for simulation purposes only
library(MTS)
# HAC estimate of standard deviations in the presence of autocorrelation and heteroscedasticity
library(sandwich)
# Extended time series
library(xts)
# Library for Diebold-Mariano test of equal forecast performance
library(multDM)
# GARCH model: for improving regression estimates
library(fGarch)
# Packages for Ridge and LASSO
library(MASS)
library(glmnet)
# Load the relevant M-SSA functionalities
# M-SSA functions
source(paste(getwd(),"/R/functions_MSSA.r",sep=""))
# Load signal extraction functions used for JBCY paper (relies on mFilter)
source(paste(getwd(),"/R/HP_JBCY_functions.r",sep=""))
# Utility functions for M-SSA, see tutorial
source(paste(getwd(),"/R/M_SSA_utility_functions.r",sep=""))
#------------------------------------------------------------------------
# Load the data and select the relevant indicators: see tutorials 7.2 and 7.3 for background
load(file=paste(getwd(),"\\Data\\macro",sep=""))
# Publication lag: we assume a lag of one quarter for BIP
lag_vec<-c(1,rep(0,ncol(data)-1))
# Plot the data
# The real-time BIP (red) is lagging the target (black) by lag_vec[1] quarters (publication lag)
par(mfrow=c(1,1))
mplot<-data[,-1]
colo<-c(rainbow(ncol(data)-1))
main_title<-paste("Quarterly indicators",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],lwd=c(2,rep(1,ncol(data)-1)),ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i],lwd=1,lty=1)
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
abline(h=0)
axis(1,at=c(1,4*1:(nrow(mplot)/4)),labels=rownames(mplot)[c(1,4*1:(nrow(mplot)/4))])
axis(2)
box()
# -The explanatory variables BIP (red line) and ip (orange) are right shifted
#   -Publication lags: BIP one quarter and ip two months (see data_monthly for the 2-month lag of ip)
# Select macro indicators for M-SSA
select_vec_multi<-c("BIP","ip","ifo_c","ESI","spr_10y_3m")
x_mat<-data[,select_vec_multi]
rownames(x_mat)<-rownames(data)
n<-dim(x_mat)[2]
# Number of observations
len<-dim(x_mat)[1]
##################################################################################
# Exercise 1 Working with M-SSA (sub-)components
#   -We rely on the design proposed in tutorial 7.3, exercise 1
# Exercise 1.0: brief summary of original M-SSA predictor (tutorial 7.3)
# Target filter: lambda_HP is the single most important hyperparameter, see tutorial 7.1 for a discussion
lambda_HP<-160
# Filter length: nearly 8 years is fine for the selected lambda_HP (filter weights decay sufficiently fast)
#   The length should be an odd number (see tutorial 7.1)
L<-31
# In-sample span for VAR, i.e., M-SSA (the proposed design is quite insensitive to this specification because the VAR is parsimoniously parameterized
date_to_fit<-"2008"
# VARMA model orders: keep the model simple in particular for short/tight in-sample spans
p<-1
q<-0
# Holding-times (HT): controls smoothness of M-SSA (the following numbers are pasted from the original predictor)
#   -Increasing these numbers leads to predictors with less zero-crossings (smoother), see tutorial 7.1
ht_mssa_vec<-c(6.380160,  6.738270,   7.232453,   7.225927,   7.033768)
names(ht_mssa_vec)<-colnames(x_mat)
# Forecast horizons: M-SSA is optimized for each forecast horizon in h_vec
h_vec<-0:6
# Forecast excesses: see tutorial 7.2, exercise 2 for background
f_excess<-c(5,rep(4,length(select_vec_multi)-1))
# Run the wrapper, see tutorial 7.2
#   -The function computes M-SSA for each forecast horizon h in h_vec
mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat,lambda_HP,L,date_to_fit,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
n<-dim(x_mat)[2]
target_obj<-HP_target_sym_T(n,lambda_HP,L)
n<-dim(x_mat)[2]
target_obj<-HP_target_sym_T(n,lambda_HP,L)
target_obj<-HP_target_sym_T(n,lambda_HP,L)
HP_target_sym_T
View(HP_target_sym_T)
# Compute target: two-sided HP
HP_target_sym_T<-function(n,lambda_HP,L)
{
HP_obj<-HP_target_mse_modified_gap(L,lambda_HP)
hp_symmetric=HP_obj$target
hp_classic_concurrent=HP_obj$hp_trend
hp_one_sided<-HP_obj$hp_mse
# Target first series
gamma_target<-c(hp_one_sided,rep(0,(n-1)*L))
# We now proceed to specifying the targets of the remaining n-1 series
for (i in 2:n)
gamma_target<-rbind(gamma_target,c(rep(0,(i-1)*L),hp_one_sided,rep(0,(n-i)*L)))
# The above target filters are one-sided (right half of two-sided filter)
# We now tell M-SSA that it has to mirror the above filters at their center points to obtain two-sided targets
symmetric_target<-T
return(list(gamma_target=gamma_target,symmetric_target=symmetric_target))
}
target_obj<-HP_target_sym_T(n,lambda_HP,L)
