axis(2)
box()
#--------------------------------------------
# 3.2 Filter series and compare classic concurrent HP with SSA
len<-100000
set.seed(1)
# White noise
a1<-0
x<-arima.sim(n = len, list(ar = a1))
# Compute filter output of SSA-HP filter
yhat<-filter(x,SSA_filt_HP,side=1)
# Compare expected and empirical holding-times
ht
compute_empirical_ht_func(yhat)
# Compute concurrent HP (classic HP nowcast)
HP_concurrent<-filter(x,hp_trend,side=1)
# Compare expected and empirical holding-times
ht_hp
compute_empirical_ht_func(HP_concurrent)
# SSA is smoother, as expected
# Plot both series: we re-scale both series to unit variance for easier visual comparison
mplot<-na.exclude(scale(cbind(yhat,HP_concurrent),scale=T,center=F))
colnames(mplot)<-c(paste("SSA(",ht,",",forecast_horizon,")",sep=""),"HP-concurrent")
# Plot a short sample of the series
par(mfrow=c(1,1))
anf<-1000
anf<-1500
anf<-3000
enf<-3300
# SSA generates ~33% less crossings
# The additional crossings of HP are typically clustered at time points where the filter output seems to hover at the zero line
# There, the SSA filter maintains a better control of noisy crossings
# At up- and downswings, away from the zero line, SSA tracks the target well, due to optimality (SSA optimization principle)
# In contrast to example 2 above, SSA now seems to lead HP-concurrent
# This lead is to some extent remarkable because the classic HP-concurrent filter is known for being 'pretty fast'
ts.plot(mplot[anf:enf,],col=colo)
mtext(paste("SSA(",ht,",",forecast_horizon,")",sep=""),col=colo[1],line=-1)
mtext("HP-concurrent",col=colo[2],line=-2)
abline(h=0)
# In this tutorial we consider an application of SSA to the Hodrick-Prescott (HP) filter
# Tutorial 2.0 provided background:
#   -For understanding HP;
#   -For justifying and motivating some of our decisions when working with HP (which differ from classic applications of HP)
# In particular we prefer HP-trend applied to differenced (stationary) data to the original HP-gap (applied to levels)
# Accordingly, we here consider the HP-trend or lowpass filter, applied to stationary data, resembling differenced economic data/series
#   -This design is used in Wildi (2024) https://doi.org/10.1007/s41549-024-00097-5: HP-trend applied to log-returns of US INDPRO (does not generate spurious cycle)
#   -All examples in this tutorial rely on artificial (simulated) stationary series: knowing the true model allows for verification of theoretical results
#     -Tutorial 5 applies HP and SSA to US-INDPRO
#     -Tutorial 7 presents an application of the more general multivariate SSA (M-SSA) to German macro-data
# We apply SSA to different targets
#   a.The one-sided MSE HP (optimal if data is white noise), applied to white noise, see example 1
#   b.The classic one-sided HP (optimal if data is an ARIMA(0,2,2)), applied to white noise, too, see example 2
#   c.The classic one-sided HP, applied to autocorrelated data, see example 5
#   d.The one-sided MSE HP, applied to autocorrelated data, too, see example 5 (just change the target specification)
#   e.The two-sided HP applied to autocorrelated data, see example 6
# Note: a look at tutorial 2.0 suggests that the two-sided target is less relevant in a BCA-context:
#   -it is too smooth: recession dips are washed-out and may eventually vanish or merge
#   -the classic one-sided HP-trend filter is relevant (it has desirable frequency-domain and time-domain characteristics)
# Main outcomes:
#   1.The classic HP-gap (as applied to non-stationary data in levels) is not suited for BCA, see example 7 below: "never use HP-gap".
#       -Therefore, we here emphasize the trend filter(s) only: as applied to stationary data (first differences of economic time series)
#   2.The classic concurrent (one-sided) HP-trend can be derived from a particular (implicit) ARIMA(0,2,2) model for the data, see tutorial 2.0.
#     -Typically, economic data does not conform to such a model, see tutorial 2.0
#     -Consequences:
#       -In contrast to usual assumptions, HP-concurrent is not an optimal (MSE) nowcast of the two-sided trend, see example 6
#       -The holding-time of HP-concurrent is rather small i.e. the filter is subject to noise-leakage
#         (noisy zero crossings, see also tutorial 2.0).
#   3.In this scenario, SSA can be applied to control and to tame the number of noisy crossings of HP
#       -We typically impose 50% larger ht or, equivalently, 33% less (noisy) crossings
#   4.Besides nowcasts (delta=0) we also consider 12-steps ahead forecasts (one year for monthly data)
#       -SSA-forecasts adopt the same stringent holding-time constraint: 33% less noisy crossings than (one-sided) HP targets (in the long run)
#       -SSA-forecasts are left-shifted (relative advancement): they generally have a lead when referenced against the concurrent benchmarks
#       -SSA real-time (concurrent) designs can be smoother as well as leading, when compared to the concurrent benchmarks
#   5. The forecast trilemma (see tutorial 0.1) is visualized in example 8 for a SSA-design targeting HP-MSE
# Note:
# -our intention is not to push a particular BCA-tool (HP filter).
# -Rather, we strive at illustrating that a particular predictor or BCA-filter (any one as long
#       as it's linear in the data) can be replicated and modified by SSA in view of addressing
#   1. smoothness (noise suppression) and
#   2. timeliness (advancement)
# -In this perspective, HP is considered as a basic platform and a vitrine for showcasing SSA
#   -We offer a number of compelling performance measures, confirming pertinence of a simple novel optimization principle
# -Applications of SSA to Hamilton's filter (proposed as an alternative to HP) and to the Baxter-King filter
#   are proposed in tutorials 3 and 4, respectively
#-----------------------------------------------------------------------
# Make a clean-sheet, load packages and functions
rm(list=ls())
library(xts)
# Load the library mFilter
# HP and BK filters
library(mFilter)
# Plot for heat map of Trilemma
library(ggplot2)
library("gplots")
# Load all relevant SSA-functions
source(paste(getwd(),"/R/simple_sign_accuracy.r",sep=""))
# Load tau-statistic: quantifies time-shift performances (lead/lag)
source(paste(getwd(),"/R/Tau_statistic.r",sep=""))
# Load signal extraction functions used for JBCY paper (relies on mFilter)
source(paste(getwd(),"/R/HP_JBCY_functions.r",sep=""))
##########################################################################################################
##########################################################################################################
# Introduction, see also tutorial 2.0
# a.Derivation of HP
# b.Brief analysis of the classic one-sided HP concurrent trend filter
# c. Summary
#--------------------------
# a. Derivation
# We use the R-package mFilter for computing HP
# Specify filter length: should be an odd number since otherwise the two-sided HP filter could not be adequately centered
L<-201
# Should be an odd number
if (L/2==as.integer(L/2))
{
print("Filter length should be an odd number")
print("If L is even then HP cannot be adequately centered")
L<-L+1
}
# Specify lambda: monthly design
lambda_monthly<-14400
par(mfrow=c(1,1))
HP_obj<-HP_target_mse_modified_gap(L,lambda_monthly)
# Bi-infinite (here truncated) two-sided (symmetric) HP
hp_target<-HP_obj$target
ts.plot(hp_target,main=paste("HP(",lambda_monthly,") two-sided target",sep=""))
# Concurrent gap: as applied to series in levels: this is a high pass filter
hp_gap=HP_obj$hp_gap
ts.plot(hp_gap)
# Concurrent HP assuming I(2)-process
# This is the Classic concurrent or one-sided low pass HP, see e.g. McElroy (2006)
hp_trend=HP_obj$hp_trend
ts.plot(hp_trend,main="One-sided HP")
# Compute lag one acf and holding time of HP concurrent
htrho_obj<-compute_holding_time_func(hp_trend)
rho_hp<-htrho_obj$rho_ff1
ht_hp<-htrho_obj$ht
ht_hp
# Compare holding-times (ht) of one- and two-sided filters
compute_holding_time_func(hp_target)$ht
# The large (atypical) discrepancy between holding-times of two- and one-sided filters is discussed in the JBCY paper
#------------------------------
# b. Classic concurrent HP trend
# Let us briefly have a look at the above discrepancy and some of its effects: for this purpose we compute and compare filter outputs
len<-L+1000
set.seed(67)
# Data: white noise (in the JBCY paper we apply the filter to log-returns of INDPRO which are close to noise)
a1<-0
x<-arima.sim(n = len, list(ar = a1))
# Compute filter output of SSA-HP filter
y_hp_concurrent<-filter(x,hp_trend,side=1)
y_hp_symmetric<-filter(x,hp_target,side=2)
# The one-sided filter (red) is much noisier, with much more zero-crossings (marked by vertical lines in plot)
ts.plot(y_hp_concurrent,main="HP: two-sided vs one-sided filter. Vertical lines indicate zero-crossings of one-sided design",col="red")
lines(y_hp_symmetric)
abline(h=0)
abline(v=which(y_hp_concurrent[2:len]*y_hp_concurrent[1:(len-1)]<0),col="red",lty=3)
mtext("Two-sided HP",col="black",line=-1)
mtext("One-sided HP",col="red",line=-2)
# Let us compute empirical holding times of both filters:
compute_empirical_ht_func(y_hp_concurrent)
compute_empirical_ht_func(y_hp_symmetric)
# The difference of empirical hts is large, as expected
# Note: for very long samples, these estimates converge to the `true' hts
ht_hp
compute_holding_time_func(hp_target)$ht
# -The plot of the time series suggests that the two-sided filter can stay away from the zero-line over long time episodes.
# -This characteristic of the two-sided HP can lead to over-smoothing, whereby critical recession dips are
#   washed-out by the filter: the resulting overdamped cycle underestimates the felt impact of crises, see Phillips and Jin (2021) for background.
# -Interestingly, the one-sided HP can track recession dips better, due to its weaker noise-suppression (smaller ht)
#   -We can gather more information by looking at frequency domain characteristics
# Let us compute and plot amplitude and time-shifts of the classic concurrent HP
K<-600
amp_obj<-amp_shift_func(K,as.vector(hp_trend),F)
par(mfrow=c(1,2))
# Amplitude
plot(amp_obj$amp,type="l",axes=F,xlab="Frequency",ylab="",main=paste("Amplitude HP",sep=""),ylim=c(0,max(amp_obj$amp)))
mtext("Amplitude classic concurrent HP trend",line=-1)
abline(h=0)
axis(1,at=1+0:6*K/6,labels=expression(0, pi/6, 2*pi/6,3*pi/6,4*pi/6,5*pi/6,pi))
#axis(1,at=1+0:6*K/6,labels=(c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi")))
axis(2)
box()
# Shift
plot(amp_obj$shift,type="l",axes=F,xlab="Frequency",ylab="",main=paste("Time-shift HP",sep=""))
mtext("Shift  classic concurrent HP trend",line=-1)
axis(1,at=1+0:6*K/6,labels=expression(0, pi/6, 2*pi/6,3*pi/6,4*pi/6,5*pi/6,pi))
#axis(1,at=1+0:6*K/6,labels=(c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi")))
axis(2)
box()
# The peak of the amplitude function corresponds roughly to a periodicity of 7 years, which is in accordance with the concept of a `business-cycle'
# The time-shift is small, in particular towards frequency zero
#   -Recall that the filter output must track the level of an I(2) series: a non-vanishing shift would generate a non-stationary (integrated) error with respect to the two-sided target output
#-----------------------
# c. Summary
# -The two-sided HP is not necessarily a worthwhile target for BCA: it is possibly `too smooth'
#   -The classic values of lambda, proposed in the literature, are eventually too large, see Phillips and Jin (2021) for background
#   -Alternatively, we may claim: the model is overtly misspecified, see tutorial 2.0
# -The classic one-sided HP, on the other hand, is less smooth: therefore it can better track short but severe recession dips
#   -The peak amplitude matches business-cycle frequencies
#   -The vanishing time-shift means that the filter is a tough benchmark
#     -The filter is typically faster than Hamilton's regression filter in real-time applications, see tutorial 3
# -We therefore propose to target two-sided  (examples 4 and 6)  as well as one-sided designs by SSA (examples 1,2,3,5 and 8)
# -Example 1 addresses specifically the one-sided hp_mse, assuming the data to be white noise
#   -Example 4 illustrates that this particular target is equivalent to the two-sided HP when the data is white noise, thus confirming proposition 5 in the JBCY paper
######################################################################################################################
######################################################################################################################
# Example 1:
# Target HP-MSE
# 1.1 Concurrent MSE estimate of bi-infinite HP assuming white noise
# This is just the truncate right tail of the symmetric filter
# This one is an optimal MSE estimate of the two-sided filter if the data is white noise
hp_mse=hp_mse_example7=HP_obj$hp_mse
par(mfrow=c(1,1))
ts.plot(hp_mse)
# Compute lag-one acf and ht for hp_mse
htrho_obj<-compute_holding_time_func(hp_mse)
rho_hp<-htrho_obj$rho_ff1
ht_mse<-htrho_obj$ht
# MSE filter is smoother than classic HP concurrent (larger ht) because white noise is `noisier' than ARIMA(0,2,2)
#   As a result, hp_mse must damp high-frequency components more strongly than hp_trend
ht_mse
#-----------------------------------------------------------------------------------
# 1.2. Setting-up SSA
# Holding time: we typically want SSA to lessen the number of zero-crossings when compared to hp_mse
ht_mse
# Therefore we select a ht which is larger than the above number
ht<-1.5*ht_mse
# Recall that we provide the lag-one acf: therefore we have to compute rho1 (corresponding to ht) for SSA
rho1<-compute_rho_from_ht(ht)
# Our selection here means that SSA will have 33% less crossings on average:
ht/ht_mse
# Forecast horizon: nowcast i.e. delta=0
forecast_horizon<-0
# We assume the data to be white noise which is the default setting (xi=NULL)
xi<-NULL
# Target: we supply the MSE concurrent filter which is in accordance with the white noise assumption
# Note: we could supply the classic concurrent HP instead (assuming an ARIMA(0,2,2)), see example 2 below
gammak_generic<-hp_mse
# SSA of HP-target
SSA_obj_HP<-SSA_func(L,forecast_horizon,gammak_generic,rho1,xi)
# This is the same as the simpler call (omitting xi in the function call assumes xi=NULL, xt=epsilont white noise)
SSA_obj_HP<-SSA_func(L,forecast_horizon,gammak_generic,rho1)
# Since xt is white noise (xi=NULL) the two SSA filters ssa_eps and ssa_x are identical, see tutorial 1
ssa_x<-SSA_obj_HP$ssa_x
SSA_filt_HP<-SSA_example1<-ssa_eps<-SSA_obj_HP$ssa_eps
#----------------------
# 1.3 Plot
colo<-c("black","brown","blue")
par(mfrow=c(1,2))
mplot<-cbind(hp_target,hp_mse)
colnames(mplot)<-c("Symmetric","Concurrent")
plot(mplot[,1],main=paste("HP(",lambda_monthly,")",sep=""),axes=F,type="l",xlab="Lag-structure",ylab="filter-weights",ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))),col=colo[1],lwd=2,lty=2)
mtext(colnames(mplot)[1],col=colo[1],line=-1)
lines(mplot[,2],col=colo[2],lwd=2,lty=1)
mtext(colnames(mplot)[2],col=colo[2],line=-2)
axis(1,at=1:nrow(mplot),labels=-1+1:nrow(mplot))
axis(2)
box()
mplot<-cbind(SSA_filt_HP,hp_mse)
colnames(mplot)<-c(paste("SSA(",round(ht,1),",",forecast_horizon,")",sep=""),"HP")
plot(mplot[,1],main=paste("Concurrent",sep=""),axes=F,type="l",xlab="",ylab="",ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))),col=colo[3],lwd=2)
mtext(colnames(mplot)[1],col=colo[3],line=-1)
lines(mplot[,2],col=colo[2],lwd=2)
mtext(colnames(mplot)[2],col=colo[2],line=-2)
axis(1,at=1:nrow(mplot),labels=-1+1:nrow(mplot))
axis(2)
box()
#------------------------
# 1.4 Checks: we check convergence of sample estimates to expectations
# -Thereby we check that the SSA optimization principle is easily interpretable and practically relevant
len<-100000
set.seed(16)
# White noise
a1<-0
x<-arima.sim(n = len, list(ar = a1))
# Compute filter output of SSA-HP filter
yhat<-filter(x,SSA_filt_HP,side=1)
# 1.4.1. Compare empirical and expected holding-times
# Compute empirical holding-time
empirical_ht<-compute_empirical_ht_func(yhat)
empirical_ht
# -compare with imposed constraint: both numbers match up to sampling error
# -SSA controls the ht, as claimed
ht
# 1.4.2. Compare lag-one acf of optimized design with imposed constraint: successful optimization means that both numbers should be close
# In our example both numbers match perfectly: the optimization converged to the global optimum
SSA_obj_HP$crit_rhoyy
rho1
# 1.4.3. Criterion values: we here check the correlation of SSA with the MSE nowcast which is our effective target
#   -Correlations with the two-sided target are obtained in examples 4 and 6 below
#   -crit_rhoyz is computed in the SSA-function: it is the true (expected) correlation of SSA with the target
#     if all assumptions are met (correct model for xt)
crit_example1<-SSA_obj_HP$crit_rhoyz
crit_example1
# We now compute the corresponding sample correlation in two steps:
# a. First derive the MSE nowcast filter output
MSE_nowcast<-filter(x,hp_mse,side=1)
# b. Second, compute the sample correlation and compare with true or expected number crit_example1
cor(yhat,MSE_nowcast,use='pairwise.complete.obs')
# Both numbers match: the sample correlation converges to the criterion value with increasing sample length
# Summary:
# -We verified that SSA maximizes the correlation of the predictor with the target, subject to the ht constraint
##############################################################################################################
###############################################################################################################
# Example 2
# Same as example 1 except that our target is the classic concurrent HP (instead of MSE)
# 2.1 Compute HP, see example 1.1 above
#-----------------------------------------------------------------------------------
# 2.2. SSA and hyperparameters
ht_hp
# Holding time: we want SSA to lessen the number of zero-crossings when compared to HP
ht<-12
# Recall that we provide the lag-one acf: therefore we have to compute rho1 corresponding to ht
rho1<-compute_rho_from_ht(ht)
# Our selection here means that SSA will have approximately 33% less crossings:
ht/ht_hp
# Forecast horizon: nowcast i.e. delta=0
forecast_horizon<-0
# Target: in contrast to example 1 above we here supply the classic HP-concurrent
gammak_generic<-hp_trend
# We assume the data to be white noise which is the default setting (xi=NULL)
xi<-NULL
# SSA of HP-target
SSA_obj_HP<-SSA_func(L,forecast_horizon,gammak_generic,rho1,xi)
# Since xt is white noise the two SSA filters ssa_eps and ssa_x are identical (deconvolution is an identity)
ssa_x<-SSA_obj_HP$ssa_x
SSA_filt_HP<-ssa_eps<-SSA_obj_HP$ssa_eps
# Plot and compare filters:
mplot<-cbind(ssa_x,hp_trend)
colnames(mplot)<-c(paste("SSA(",ht,",",forecast_horizon,")",sep=""),"HP-concurrent")
colo<-c("blue","green")
# The typical noise-shape or tip of SSA is due to an implicit boundary constraint which states that the coefficient at lag -1 vanishes, see theorem 1 in JBCY paper
par(mfrow=c(1,1))
plot(mplot[,1],main=paste("HP(",lambda_monthly,")",sep=""),axes=F,type="l",xlab="Lag-structure",ylab="filter-weights",ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))),col=colo[1],lwd=2,lty=1)
mtext(colnames(mplot)[1],col=colo[1],line=-1)
lines(mplot[,2],col=colo[2],lwd=2,lty=1)
mtext(colnames(mplot)[2],col=colo[2],line=-2)
axis(1,at=1:nrow(mplot),labels=-1+1:nrow(mplot))
axis(2)
box()
#--------------------------------------------
# 2.3 Filter series and compare classic concurrent HP with SSA
len<-100000
set.seed(1)
# White noise
a1<-0
x<-arima.sim(n = len, list(ar = a1))
# Compute filter output of SSA-HP filter
yhat<-filter(x,SSA_filt_HP,side=1)
# Compare expected and empirical holding-times
ht
compute_empirical_ht_func(yhat)
# Compute concurrent HP
HP_concurrent<-filter(x,hp_trend,side=1)
# Compare expected and empirical holding-times
ht_hp
compute_empirical_ht_func(HP_concurrent)
# As expected, SSA generates ~33% less zero-crossings
# Plot both series: we re-scale both series to unit variance for better comparison (note that SSA-scaling is arbitrary)
mplot<-na.exclude(cbind(yhat,HP_concurrent))
colnames(mplot)<-c(paste("SSA(",ht,",",forecast_horizon,")",sep=""),"HP-concurrent")
# Plot a short sample of the series
par(mfrow=c(1,1))
anf<-500
enf<-1000
anf<-1000
enf<-1500
# Both series look similar but SSA generates ~33% less crossings
# The additional crossings of HP are typically clustered at time points where the filter output hovers over the zero line
# There, the SSA filter maintains a better control of noisy crossings (see amplitude function below for a formal explanation of these properties)
# At up- and downswings, away from the zero line, SSA tracks the target well, due to optimality (SSA optimization principle)
ts.plot(mplot[anf:enf,],col=colo)
mtext(paste("SSA(",ht,",",forecast_horizon,")",sep=""),col=colo[1],line=-1)
mtext("HP-concurrent",col=colo[2],line=-2)
abline(h=0)
#------------------------------------------
# 2.4 Look at shift
# The above plot also suggests that the concurrent HP is slightly left-shifted (small lead): see also phase-lag plot below for formal background
# Here we compute the shift at zero-crossings: the tau-statistic is proposed in Wildi, M. (2024) https://doi.org/10.1007/s41549-024-00097-5 and explained in previous tutorials
#   -The minimum value (trough) indicates a relative lead (left of zero) or lag (right of zero) of the series in the first column of the matrix (here: SSA)
# The slight asymmetry suggests that SSA is marginally lagging HP-concurrent (by roughly half a time-unit)
shift_tau_obj<-compute_min_tau_func(mplot)
#-------------------------------------------
# 2.5 Look at amplitude and phase-shift
K<-600
amp_obj_SSA<-amp_shift_func(K,as.vector(SSA_filt_HP),F)
amp_obj_HP<-amp_shift_func(K,hp_trend,F)
par(mfrow=c(2,1))
mplot<-scale(cbind(amp_obj_SSA$amp,amp_obj_HP$amp),scale=T,center=F)
colnames(mplot)<-c(paste("SSA(",ht,",",forecast_horizon,")",sep=""),"HP-concurrent")
# The HP filter is a lowpass applied to differences (returns)
# The amplitude function of SSA is closer to zero in stop band: stronger smoothing and less noisy zero-crossings
# This typical property of SSA-smoothing designs has coined the term 'noisy crossings'
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Amplitude HP",sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
if (ncol(mplot)>1)
{
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:6*K/6,labels=expression(0, pi/6, 2*pi/6,3*pi/6,4*pi/6,5*pi/6,pi))
#axis(1,at=1+0:6*K/6,labels=(c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi")))
axis(2)
box()
mplot<-cbind(amp_obj_SSA$shift,amp_obj_HP$shift)
colnames(mplot)<-c(paste("SSA(",ht,",",forecast_horizon,")",sep=""),"HP-concurrent")
# The larger phase-lag of SSA implies a slight lag relative to HP-concurrent: roughly half a time-unit (confirming the above tau-statistic in the time-domain)
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Phase-shift ",sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
if (ncol(mplot)>1)
{
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:6*K/6,labels=expression(0, pi/6, 2*pi/6,3*pi/6,4*pi/6,5*pi/6,pi))
#axis(1,at=1+0:6*K/6,labels=(c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi")))
axis(2)
box()
# Findings: SSA lags slightly behind HP-concurrent (by roughly half a time-unit) and it generates ~33% less noisy crossings
###########################################################################################################
############################################################################################################
# Example 3:
# We can address lags (time shifts) by selecting a different forecast_horizon, see Wildi, M. (2024) https://doi.org/10.1007/s41549-024-00097-5
# We here look specifically at a one-year forecast
# Note, however, that we keep the holding-time fixed:
#   -The resulting SSA-filter will retain smoothness (noise suppression)
#   -But it will be slightly faster (leading instead of lagging as in example 2)
# SSA keeps `smoothness' fixed and trades (exchanges) `lead' against MSE-performances, see tutorial 0.1 and example 8 below (trilemma)
# 3.1. SSA and hyperparameters
# Forecast horizon: one-year forecast
forecast_horizon<-12
# Holding time is kept fixed, see example 2
ht<-12
# Recall that we provide the lag-one acf: therefore we have to compute rho1 corresponding to ht
rho1<-compute_rho_from_ht(ht)
# Our selection here means that SSA will have approximately 33% less crossings:
ht/ht_hp
# Target: like example 2 we here supply the classic HP-concurrent
gammak_generic<-hp_trend
# We assume the data to be white noise
# SSA of HP-target
SSA_obj_HP<-SSA_func(L,forecast_horizon,gammak_generic,rho1)
# Since xt is white noise the two SSA filters ssa_eps and ssa_x are identical (deconvolution is an identity)
ssa_x<-SSA_obj_HP$ssa_x
SSA_filt_HP<-ssa_eps<-SSA_obj_HP$ssa_eps
# Plot and compare filters:
mplot<-cbind(ssa_x,hp_trend)
colnames(mplot)<-c(paste("SSA(",ht,",",forecast_horizon,")",sep=""),"HP-concurrent")
colo<-c("blue","green")
# Note the different scales of SSA and MSE
#   -As noted above, asking for a lead as well as for improved smoothness will affect MSE-performances
#   -As an effect, the scale of SSA is smaller: zero-shrinkage
#   -One could re-scale and inflate the SSA-filter but MSE performances would be even worse (we here see the optimal scaling)
# Note also that zero-crossings or correlations are indifferent to scalings
par(mfrow=c(1,1))
# The typical noise-shape or tip of SSA is due to an implicit boundary constraint which states that the coefficient at lag -1 vanishes, see theorem 1 in JBCY paper
plot(mplot[,1],main=paste("HP(",lambda_monthly,")",sep=""),axes=F,type="l",xlab="Lag-structure",ylab="filter-weights",ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))),col=colo[1],lwd=2,lty=1)
mtext(colnames(mplot)[1],col=colo[1],line=-1)
lines(mplot[,2],col=colo[2],lwd=2,lty=1)
mtext(colnames(mplot)[2],col=colo[2],line=-2)
axis(1,at=1:nrow(mplot),labels=-1+1:nrow(mplot))
axis(2)
box()
#--------------------------------------------
# 3.2 Filter series and compare classic concurrent HP with SSA
len<-100000
set.seed(1)
# White noise
a1<-0
x<-arima.sim(n = len, list(ar = a1))
# Compute filter output of SSA-HP filter
yhat<-filter(x,SSA_filt_HP,side=1)
# Compare expected and empirical holding-times
ht
compute_empirical_ht_func(yhat)
# Compute concurrent HP (classic HP nowcast)
HP_concurrent<-filter(x,hp_trend,side=1)
# Compare expected and empirical holding-times
ht_hp
compute_empirical_ht_func(HP_concurrent)
# SSA is smoother, as expected
# Plot both series: we re-scale both series to unit variance for easier visual comparison
mplot<-na.exclude(scale(cbind(yhat,HP_concurrent),scale=T,center=F))
colnames(mplot)<-c(paste("SSA(",ht,",",forecast_horizon,")",sep=""),"HP-concurrent")
# Plot a short sample of the series
par(mfrow=c(1,1))
anf<-1000
anf<-1500
anf<-3000
enf<-3300
# SSA generates ~33% less crossings
# The additional crossings of HP are typically clustered at time points where the filter output seems to hover at the zero line
# There, the SSA filter maintains a better control of noisy crossings
# At up- and downswings, away from the zero line, SSA tracks the target well, due to optimality (SSA optimization principle)
# In contrast to example 2 above, SSA now seems to lead HP-concurrent
# This lead is to some extent remarkable because the classic HP-concurrent filter is known for being 'pretty fast'
ts.plot(mplot[anf:enf,],col=colo)
mtext(paste("SSA(",ht,",",forecast_horizon,")",sep=""),col=colo[1],line=-1)
mtext("HP-concurrent",col=colo[2],line=-2)
abline(h=0)
ht
compute_empirical_ht_func(yhat)
ht_hp
compute_empirical_ht_func(HP_concurrent)
